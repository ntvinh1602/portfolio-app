-- 1. Create a table to act as a queue for revalidation tasks.
CREATE TABLE IF NOT EXISTS public.revalidation_queue (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    processed_at TIMESTAMPTZ,
    status TEXT DEFAULT 'pending' NOT NULL, -- pending, processing, completed, failed
    job_type TEXT NOT NULL, -- 'tag' or 'path'
    identifier TEXT NOT NULL, -- The tag name or the path string
    attempts INT DEFAULT 0 NOT NULL,
    last_error TEXT,
    CONSTRAINT "revalidation_queue_job_type_check" CHECK ((job_type IN ('tag', 'path')))
);

-- Create a unique index to prevent duplicate pending jobs
CREATE UNIQUE INDEX revalidation_queue_unique_pending_job_idx
ON public.revalidation_queue (job_type, identifier)
WHERE (status = 'pending');


-- 2. Create a function that contains the mapping logic.
-- This function adds the correct revalidation jobs to the queue based on the table name.
CREATE OR REPLACE FUNCTION queue_revalidation_jobs(table_name TEXT)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  -- This function now maps table changes to all affected cache tags and paths.
  
  -- A change in transactions, prices, rates, or debts affects performance data.
  IF table_name IN ('transactions', 'daily_stock_prices', 'daily_exchange_rates', 'debts') THEN
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('tag', 'performance-data') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/benchmark-chart') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/equity-chart') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/first-snapshot-date') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/monthly-pnl') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/monthly-twr') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/pnl') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/twr') ON CONFLICT DO NOTHING;
  END IF;

  -- A change in transactions, prices, rates, or debts also affects asset data.
  IF table_name IN ('transactions', 'daily_stock_prices', 'daily_exchange_rates', 'debts') THEN
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('tag', 'asset-data') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/asset-summary') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/stock-holdings') ON CONFLICT DO NOTHING;
  END IF;

  -- Specific paths for specific table changes
  IF table_name = 'transactions' THEN
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/monthly-expenses') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/transaction-feed') ON CONFLICT DO NOTHING;
  END IF;

  IF table_name = 'debts' THEN
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/debts') ON CONFLICT DO NOTHING;
  END IF;

  -- A change in market indices has a very limited impact
  IF table_name = 'daily_market_indices' THEN
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('tag', 'performance-data') ON CONFLICT DO NOTHING;
    INSERT INTO public.revalidation_queue (job_type, identifier) VALUES ('path', '/api/query/benchmark-chart') ON CONFLICT DO NOTHING;
  END IF;

END;
$$;


-- 3. Create a simple, generic trigger function.
CREATE OR REPLACE FUNCTION handle_table_change_and_queue()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Call the main logic function, passing the table name
  PERFORM queue_revalidation_jobs(TG_TABLE_NAME);
  RETURN NULL; -- The return value is ignored for AFTER triggers
END;
$$;


-- 4. Attach the trigger to all relevant tables.
-- We use AFTER INSERT OR UPDATE OR DELETE to catch all data modifications.
-- Using FOR EACH STATEMENT is more efficient as the function runs once per transaction, not per row.

DROP TRIGGER IF EXISTS on_transactions_change ON transactions;
CREATE TRIGGER on_transactions_change
AFTER INSERT OR UPDATE OR DELETE ON transactions
FOR EACH STATEMENT EXECUTE FUNCTION handle_table_change_and_queue();

DROP TRIGGER IF EXISTS on_daily_stock_prices_change ON daily_stock_prices;
CREATE TRIGGER on_daily_stock_prices_change
AFTER INSERT OR UPDATE OR DELETE ON daily_stock_prices
FOR EACH STATEMENT EXECUTE FUNCTION handle_table_change_and_queue();

DROP TRIGGER IF EXISTS on_daily_exchange_rates_change ON daily_exchange_rates;
CREATE TRIGGER on_daily_exchange_rates_change
AFTER INSERT OR UPDATE OR DELETE ON daily_exchange_rates
FOR EACH STATEMENT EXECUTE FUNCTION handle_table_change_and_queue();

-- Re-adding the trigger on 'debts' table as requested
DROP TRIGGER IF EXISTS on_debts_change ON debts;
CREATE TRIGGER on_debts_change
AFTER INSERT OR UPDATE OR DELETE ON debts
FOR EACH STATEMENT EXECUTE FUNCTION handle_table_change_and_queue();

DROP TRIGGER IF EXISTS on_daily_market_indices_change ON daily_market_indices;
CREATE TRIGGER on_daily_market_indices_change
AFTER INSERT OR UPDATE OR DELETE ON daily_market_indices
FOR EACH STATEMENT EXECUTE FUNCTION handle_table_change_and_queue();